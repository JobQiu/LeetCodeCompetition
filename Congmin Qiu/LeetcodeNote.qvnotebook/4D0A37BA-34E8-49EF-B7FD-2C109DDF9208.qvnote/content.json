{
  "title": "Array",
  "cells": [
    {
      "type": "markdown",
      "data": "# Array\n\n## 4. Median of Two Sorted Arrays\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/\n\nGiven two sorted arrays, we need to find the median of all the numbers in these two arrays.\n\n\nFor example, if nums1 = [1, 2], nums2 = [3, 4], we should return 2.5\n\n### Solution\n\nOne easy solution is make a copy and use two pointers to get merged sorted array, contains all numbers, and then find the median.\nWhich cost O(N) time and O(N) space.\n\nWe can improve the space by just updating two pointers, until i+j == (len(A) + len(B)) // 2, then it will be O(N) time and O(1) space.\n\nOne faster solution: https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481\n\nsplit the first array using index i,\n[0: i-1] belong to the left part, and [i:] belong to the right part.\nsplit the second array using index j,\n[0: j-1] belong to the left part, and [j:] belong to the right part.\n\ni + j == (len(A) + len(B)) // 2\n\n\n```python\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2) -> float:\n        l1, l2 = len(nums1), len(nums2)\n        if l1 > l2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        if l1 == 0:\n            if len(nums2) % 2 == 1:\n                return nums2[len(nums2)//2]\n            else:\n                return (nums2[len(nums2)//2-1] + nums2[len(nums2)//2]) / 2.0\n\n        halflen = (len(nums1) + len(nums2)+1) // 2\n        lo, hi = 0, len(nums1)\n        i = (lo + hi) // 2\n        j = halflen - i\n\n\n        lo = 0\n        hi = len(nums1)\n        while lo <= hi:\n            i = (lo + hi) // 2\n            j = halflen - i\n\n            if i<len(nums1) and j > 0 and nums2[j-1] > nums1[i]:\n                lo = i + 1\n            elif i >0 and j < len(nums2) and nums1[i-1] > nums2[j]:\n                hi = i\n            else:\n                break\n\n        left = []\n        if i > 0:\n            left.append(nums1[i-1])\n        if j > 0:\n            left.append(nums2[j-1])\n        leftmax=  max(left)\n        if (len(nums1) + len(nums2)) % 2 == 1:\n            return leftmax\n\n        right = []\n        if i < len(nums1):\n            right.append(nums1[i])\n        if j < len(nums2):\n            right.append(nums2[j])\n        rightmin = min(right)\n        return (leftmax+rightmin) / 2.0\n```\n- Status: need redo, too many corner case\n- Time: Sep 1, 2019 3:28 PM\n\n## 11. Container With Most Water\nhttps://leetcode.com/problems/container-with-most-water/\n\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" width=\"500px\"/>\nIdea, use two pointers.\n\n- Status : skip\n- Time: Sep 1, 2019 3:28 PM\n\n## 53. Maximum Subarray\n\n```\nInput: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n```\n\nIdea: use two variable, 1. `result` to store the global optimal result, 2. `curMax` to store the sum of subarray end at current index.\n\n```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        res = nums[0]\n        curMax = nums[0]\n\n        for num in nums[1:]:\n            curMax = max(curMax + num, num)\n            res = max(res, curMax)\n        return res\n```\n\n- Status: skip\n- Time: Sep 1, 2019 3:33 PM\n\n---\n\n## 42. Trapping Rain Water\n\nhttps://leetcode.com/problems/trapping-rain-water/\n\n\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" width=\"500px\"/>\n\nidea, use two pointers,\n\n```python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        l, r = 0, len(height)-1\n        maxleft, maxright = 0, 0\n        ans = 0\n        while l<r:\n            if height[l]<height[r]:\n                if height[l]>=maxleft:\n                    maxleft = height[l]\n                else:\n                    ans += maxleft - height[l]\n                l+=1\n            else:\n                if height[r]>=maxright:\n                    maxright = height[r]\n                else:\n                    ans += maxright - height[r]\n                r-=1\n        return ans\n```\n\n- Status: skip\n- Time: Sep 1, 2019 3:40 PM\n\n---\n\n## 122. Best Time to Buy and Sell Stock II\n\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n\nGiven an array, [7,1,5,3,6,4], the number means the price of stock at a certain day, you can complete as many transactions as you want. can't buy and sell in the same day.\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        for i in range(1, len(prices)):\n            res += max(prices[i] - prices[i-1], 0)\n        return res\n```\n\n- Status: may skip\n- Time: Sep 1, 2019 3:56 PM\n\n----\n\n## 85. Maximal Rectangle\n\nhttps://leetcode.com/problems/maximal-rectangle/\n\nGiven a matrix, return the \n```\nInput:\n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\nOutput: 6\n```\n\n```python\nclass Solution:\n    def maximalRectangle(self, m: List[List[str]]) -> int:\n        \n        res = 0\n        if not m or not m[0]:\n            return res \n        col = len(m[0])\n        \n        l = [0] * col\n        r = [col] * col\n        h = [0] * col\n        \n        for row in m:\n            left, right = 0, col\n            \n            for j in range(col):\n                if row[j] == '1':\n                    h[j] += 1\n                else:\n                    h[j] = 0\n            \n            for j in range(col):\n                if row[j] == '1': \n                    l[j] = max(left, l[j])\n                else:\n                    l[j] = 0\n                    left = j+1\n            \n            for j in reversed(range(col)):\n                if row[j] == '1':\n                    r[j] = min(right, r[j])\n                else:\n                    r[j] = col\n                    right = j\n            \n            for j in range(col):\n                res = max(res, h[j] * (r[j]-l[j]))\n        return res\n```\n\n- Status: need redo and explain to myself\n- Time: Sep 2, 2019 9:00 AM\n\n--- \n\n## 41. First Missing Positive\n\nhttps://leetcode.com/problems/first-missing-positive/\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \n        if not nums :\n            return 1\n        l = len(nums)\n        \n        for i in range(len(nums)):\n            while nums[i] > 0 and nums[i] <= l and nums[i] != (i+1):\n                j = nums[i]-1\n                if nums[i] == nums[j]:\n                    break\n                nums[i], nums[j] = nums[j], nums[i]\n        \n        for i in range(len(nums)):\n            if nums[i] != i+1:\n                return i +1\n        \n        return l+1\n```\n\n- Status: need redo, a lot of corner cases\n- Time: Sep 2, 2019 9:20 AM\n\n--- \n\n## 31. Next Permutation\n\nhttps://leetcode.com/problems/next-permutation/\n\n```python\n\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        \n        l = len(nums)\n\n        i = l- 1\n        \n        while i > 0 and nums[i] <= nums[i-1]:\n            i -= 1\n        \n        if not i :\n            nums.reverse()\n            return \n        \n        \"\"\"\n        1 2 3, \n        i -> 3\n        1 2 3 4 3 2 1\n        i -> 4\n        \"\"\"\n        \n        j = i\n        while j < l and nums[j] > nums[i-1]:\n            j += 1\n        \n        def swap(m,n ): \n            nums[m], nums[n] = nums[n], nums[m]\n        swap(i-1,j-1)\n        \n        o, k = i, l-1\n        while o < k:\n            swap(o, k)\n            o += 1\n            k -= 1\n```\n\n- Status: need redo\n- Time: Sep 2, 2019 1:14 PM\n\n---\n\n## 287. Find the Duplicate Number\n\nhttps://leetcode.com/problems/find-the-duplicate-number/\n\n---\n\n## 229. Majority Element II\n\nhttps://leetcode.com/problems/majority-element-ii/\n\n---\n\n## 621. Task Scheduler\n\nhttps://leetcode.com/problems/task-scheduler/\n\n---\n\n## 228. Summary Ranges\n\nhttps://leetcode.com/problems/summary-ranges/\n\n--- \n\n## 717. 1-bit and 2-bit Characters\n\nhttps://leetcode.com/problems/1-bit-and-2-bit-characters/\n\n```python\nclass Solution:\n    def isOneBitCharacter(self, bits: List[int]) -> bool:\n        ones = 0\n        for i in reversed(range(len(bits)-1)):\n            if bits[i] == 1:\n                ones+=1\n            else:\n                break\n        return ones%2==0\n```\n\n---\n\n## 189. Rotate Array\n\nhttps://leetcode.com/problems/rotate-array/\n\n\n\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n---\n"
    }
  ]
}