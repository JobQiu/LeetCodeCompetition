{
  "title": "DP",
  "cells": [
    {
      "type": "markdown",
      "data": "## 123. Best Time to Buy and Sell Stock III\n\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\n\n## 887. Super Egg Drop\n\nhttps://leetcode.com/problems/super-egg-drop/\n\nGiven K eggs and N floors. We want to know exactly from which floor we drop an egg, the egg will break. How many moves we need in the worst situation to know it?\n\n### Solution\n\nThe idea here, is to use a dp. to see with K eggs and n moves, how many floors we can test. \n\n`dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1,`\n\nif egg breaks, we have m-1 moves and k-1 eggs, and all the floors above, we don't need to check them, because egg will definitely break. \nif egg don't break, we have m-1 moves and k eggs.\n\nThe following is the optimized version with only 1d space. \n\n\n```python\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        f = [0]\n        for move in range(1, N + 1):\n            f += [f[-1]]\n            for k in range(move, 0, -1):\n                f[k] = f[k] + f[k - 1] + 1\n            print(f)\n            if f[min(K, move)] >= N:\n                return move\n        return -1\n```\n\nhttps://leetcode.com/problems/super-egg-drop/discuss/158974/C%2B%2BJavaPython-2D-and-1D-DP-O(KlogN)\n\n- Status: need redo\n- Time: Sep 11, 2019 3:03 PM \n\n## 639. Decode Ways II\n\nhttps://leetcode.com/problems/decode-ways-ii/\n\nstart time : Sep 2, 2019 7:09 PM\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\nGiven a string only contains 0-9 and `*`, `*` can be treat as any number between 1 and 9. How many combination can it be translated? \n\nFor example, '*' has 9 translations, and '1\\*' has 18 translations. '1\\*1' -> 20. \n\n\n\n```python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        \"\"\"\n        \n        \"\"\"\n        \n        e0, e1, e2 = 1, 0, 0\n        MOD = 10**9 + 7\n        for c in s:\n            if c == '*':\n                f0 = 9*(e0+e1) + 6*e2\n                f1 = e0\n                f2 = e0\n                pass\n            else:\n                f0 = (c > '0') * e0 + e1 + e2*(c <= '6')\n                if c == '1':\n                    f1 = e0\n                else:\n                    f1 = 0\n                if c == '2':\n                    f2 = e0\n                else:\n                    f2 = 0\n            e0, e1, e2 = f0%MOD, f1, f2\n        return e0\n```\n\n\n- Status: need redo\n- Time: Sep 2, 2019 7:22 PM"
    },
    {
      "type": "markdown",
      "data": "---\n\n## 10. Regular Expression Matching\n\nhttps://leetcode.com/problems/regular-expression-matching/\n\n```python\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        \n        \"\"\"\n        \n        sl = len(s)\n        pl = len(p)\n\n        dp = [[0] * (pl + 1) for _ in range(sl+1)]\n        dp[0][0] = 1 \n        \"\"\"\n        def printdp( ): \n            print(\"p->  \",\", \".join(p))\n            for idx, line in enumerate(dp):\n                temp = \" \"\n                if idx > 0:\n                    temp = s[idx-1]\n\n                print(temp,line)\n           \"\"\"     \n        for idx, ch in enumerate(p):\n            if ch == '*':\n                dp[0][idx+1] = dp[0][idx-1]\n\n        for i in range(sl):\n            for j in range(pl):\n                if s[i] == p[j] or p[j] == '.':\n                    dp[i+1][j+1] = dp[i][j]\n                elif p[j] == '*':\n                    if p[j-1] == s[i] or p[j-1] == '.':\n                        dp[i+1][j+1] = max([dp[i][j+1], dp[i+1][j-1],dp[i+1][j]])\n                    else:\n                        dp[i+1][j+1] = dp[i+1][j-1]\n        return dp[-1][-1] == 1\n\n\n```\n\n- Status: need redo\n- Time: Sep 2, 2019 8:13 PM"
    },
    {
      "type": "markdown",
      "data": "\n---\n\n## 321. Create Maximum Number\n\nhttps://leetcode.com/problems/create-maximum-number/\n\n- Status: need redo \n- Time: Sep 3, 2019 2:06 PM\n\n---\n\n## 629. K Inverse Pairs Array\n\n![IMG_8564.png](quiver-image-url/8AF31251A4DE96E0B3D04C216901954E.png =1068x927)\n\n## 871. Minimum Number of Refueling Stops\n\npass\n\n---\n\n## 44. Wildcard Matching\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\n\nInput:\ns = \"acdcb\"\np = \"a*c?b\"\nOutput: false\n\n\nHow to develop a dp to process. \n\n```python\n\"\"\"\n    a * c ? b\na 1 1 1 0 0 0  \nc 0 0 0 1 0 0 \nd 0 0 0 0 1 0\nc 0 0 0 0 0 0\nb\n\"\"\"\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \n        dp = [[0] * (len(p)+1) for _ in range(len(s)+1)]\n        dp[0][0] = 1\n        \n        for j in range(len(p)):\n            if p[j] == \"*\":\n                dp[0][j+1]= dp[0][j]\n\n        for i in range(len(s)):\n            for j in range(len(p)):\n                \n                if s[i]==p[j] or p[j] == \"?\":\n                    dp[i+1][j+1] = dp[i][j]\n                \n                elif p[j] == \"*\":\n                    dp[i+1][j+1] = max([dp[i+1][j], dp[i][j], dp[i][j+1]])\n                    \n        return dp[-1][-1]\n```\n\nThe DP solution is super slow, and we can also save the space by using 1d vector rather than 2d.\n\nAnd we can start from \n\n\n\n\n\n\n\n\n\n---\n\n"
    }
  ]
}