{
  "title": "Greedy",
  "cells": [
    {
      "type": "markdown",
      "data": "# Greedy\n\n## 406. Queue Reconstruction by Height\n\nhttps://leetcode.com/problems/queue-reconstruction-by-height/\n\nGiven an array, for example, `[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]`. The first number in each tuple means the height, and the second number should be the number of higher people before him. We need to sort these tuples to make it right. For this example, the answer is `[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]`.\n\n### Solution\n\nOne idea is by sorting according (-height, numPeopleHigherBefore).\nFor this example, after sorting, the array becomes: `[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]`.\n\nThen insert them into an empty array `[]` by result.insert(_2, (_1,_2)). For this example, it's like this:\n- [**<font color=red>[7,0]</font>**]\n- [[7,0], **<font color=red>[7,1]</font>**]\n- [[7,0], **<font color=red>[6,1]</font>**, [7,1]]\n- [**<font color=red>[5,0]</font>**, [7,0], [6,1], [7,1]]\n- [[5,0], [7,0], **<font color=red>[5,2]</font>**, [6,1], [7,1]]\n- [[5,0], [7,0], [5,2], [6,1], **<font color=red>[4,4]</font>**, [7,1]]\n\nBecause insert low people later will not influence those higher people.\n\n``` python\nclass Solution:\n    def reconstructQueue(self, people: List[List[int]]) \\\n    -> List[List[int]]:\n\n        def getKey(p ):\n            return (-p[0], p[1])\n\n        people = sorted(people, key=getKey)\n        res = []\n        for v, idx in people:\n            res.insert(idx, [v, idx])\n        return res\n```\n- Analysis: to sort the array, we need O(logN) time, and to insert, no matter you're using linked list or array list, you will need O(N) time to insert one tuple, then it's O(N^2).\n- Status: May need redo\n- Comment: brainteaser?\n- Time: Aug 28, 2019 9:39 AM\n\n---\n\n\n## 316. Remove Duplicate Letters\n\nhttps://leetcode.com/problems/remove-duplicate-letters/\n\nGiven a string only contains little letters, for example, `bcabc`, we need to remove all duplicate letters. for this example, it can be `bca`, `cab`, `abc`. And we need to return the one which is the smallest in lexicographical order among all possible results. For this example, we need to return `abc`.\n\n### Solution\n\nOne idea is using a counter. For the example above it will be\nb-2, c-2, a-1. And then use one pointer. Move this pointer and decrease the count corresponding to the character. Keep track the smallest lexicographical character.\n\n```\nbcabc\n|\nb-1,c-2,a-1, smallest is b\nbcabc\n |\nb-1,c-1,a-1, smallest is b\nbcabc\n  |\nb-1,c-1,a-0, smallest is a, break\n```\n\nso the result should be \"a\"+removeDuplicateLetters(\"bc\"), which is \"abc\".\n\n```python\nfrom collections import Counter\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        if not s:\n            return \"\"\n        c = Counter(s)\n        pos = 0\n\n        for idx, ch in enumerate(s):\n            if ch < s[pos]:\n                pos = idx\n            c[ch] -= 1\n            if c[ch] == 0:\n                break\n\n        return s[pos] + self.removeDuplicateLetters(s[pos+1:].replace(s[pos],\"\"))\n```\n\nBut this is pretty slow.\nWe need to count every time we invoke this method, and because of recursion, so in the worst situation, it need O(N^2) time.\n\nAnother idea is using a Stack, continue to pop if current char is smaller than before. Unless the previous char is at its final position.\n\n```python\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n\n        final = {ch:idx for idx,ch in enumerate(s)}\n        stack = []\n        seen = set()\n\n        for idx, ch in enumerate(s):\n            if ch not in seen:\n                while stack and stack[-1] > ch and final[stack[-1]] > idx:\n                    temp = stack.pop()\n                    seen.remove(temp)\n                stack.append(ch)\n                seen.add(ch);\n        return \"\".join(stack)\n```\n\n- Status: need redo\n- Time : Aug 28, 2019 6:15 PM\n\n---\n\n## 45. Jump Game II\nhttps://leetcode.com/problems/jump-game/\nhttps://leetcode.com/problems/jump-game-ii/\n\nGiven an array, for example, [2,3,1,1,4], the number means from that position, the length you can jump.\nFrom 2, you can jump to 3 or 1.\nFrom 3, you can jump to 1 or 1 or 4.\nSo you only need 2 jumps to the end. You can always reach the end, so we don't need to worry about what to return when we can't reach the end.\n\n### Solution:\n\nSo what we can do is using something like bfs. `start = 0, end = 0.` Iterate this range to get next start and end. Keep doing this until we reach the end.\n\n```python\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        if not nums or len(nums) <= 1:\n            return 0\n\n        res = 0\n        start = 0\n        end = 0\n        while end < len(nums):\n            nextEnd = end\n            for i in range(start, end+1):\n                nextEnd = max(nextEnd, i + nums[i])\n                if nextEnd >= len(nums)-1:\n                    return res + 1\n\n            start = end + 1\n            end = nextEnd\n            res += 1\n        return res\n```\n\nOther people's solution\n\n```python\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        len0 = len(nums)\n        res = end = goal = 0\n        for i in range(len0-1):\n            goal = max(goal, i+nums[i])\n            if i == end:\n                res += 1\n                end = goal\n        return res\n```\n\n- Status: pass\n- Comment: a classical bfs problem\n- Time: Aug 28, 2019 6:31 PM\n\n---\n\n## 134. Gas Station\nhttps://leetcode.com/problems/gas-station/\n\nGiven two arrays, gas and cost: gas  = [1,2,3,4,5]\ncost = [3,4,5,1,2],\n\nthe gas means at a certain station, how much gas you can get, and cost means from a certain station to the next station, how much gas you will spend. The final station's next station is the first one.\n\nThe task is to find a station, from this station you can go to the end, then from the first station, you can reach this station again as a cycle. Assume there is only one possible station, or if not possible, return -1.\n\n### Solution\n\nUse 2 pointers. `start = len(gas)-1, end = 0`. Move start backward when gas is not enough, and move end forward when gas is still > 0.\n\n```python\nclass Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        start = len(gas) - 1\n        end = 0\n\n        cur = gas[-1] - cost[-1]\n        while start > end:\n            if cur > 0:\n                cur += (gas[end] - cost[end])\n                end += 1\n            else:\n                start -= 1\n                cur += (gas[start]- cost[start])\n        if cur >= 0:\n            return start\n        return -1\n```\n\n- Status: may need redo\n- Comment: a little brainteaser.\n- Time: Aug 28, 2019 6:59 PM\n\n----\n\n## 763. Partition Labels\n\nhttps://leetcode.com/problems/partition-labels/\n\nGiven a string, for example, `ababcbacadefegdehijhklij`. Split it, and one kind of character will only exist in one of those strings after splitting.\nFor this example, it can be split into \"ababcbaca\", \"defegde\", \"hijhklij\", we need to return the length of them, i.e., `[9,7,8]`.\n\n\n### Solution\n\nWe use a variable `last` to tracking the last position of all characters in this substring.\n\nFor the example above, the last index of every character is:\n{'a': 8, 'b': 5, 'c': 7, 'd': 14, 'e': 15, 'f': 11, 'g': 13, 'h': 19, 'i': 22, 'j': 23, 'k': 20, 'l': 21}\n\nSo we iterate the string, and i from 0 to 8, the variable last, will be the max([8,5,7]), so when i = 8, we reach the current last, we stop and record it and start again from i=9.\n\n```python\nclass Solution:\n    def partitionLabels(self, S: str) -> List[int]:\n        res = []\n        if not S:\n            return res\n\n        m = {ch:idx for idx, ch in enumerate(S)}\n\n        last = 0\n        start = 0\n        for idx, ch in enumerate(S):\n            if m[ch] > last:\n                last = m[ch]\n            if last == idx:\n                res.append(last-start+1)\n                start = last+1\n        return res\n```\n\n- Status: need redo\n- Comment: kind like merge intervals if you consider the start and end of a character as an interval.\n- Time: Aug 28, 2019 7:38 PM\n\n---\n\n## 135. Candy\nhttps://leetcode.com/problems/candy/\n- Each child must have at least one candy.\n- Children with a higher rating get more candies than their neighbors.\n\nFor example, [1, 0, 2],\nwe should assign [2,1,2], so we need to return 5.\n\n### Solution\n\nWe can solve it use a two pass.\n\nthe forward pass, if current weight is larger than before, dp[i] = dp[i-1] + 1\nelse = 1.\n\nFor the backward pass, do the same thing, but pick the larger peak.\n\nFor our example, [1, 0, 2]\nafter the forward pass, it will be\n[1, 1, 2]\nafter the backward pass, it will be [2, 1, 2]\n\n```python\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n\n        if not ratings:\n            return 0\n\n        if len(ratings) <= 1:\n            return len(ratings)\n\n        dp = [1] * len(ratings)\n\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                dp[i] = dp[i-1] + 1\n\n        for i in reversed(range(len(ratings)-1)):\n            if ratings[i] > ratings[i+1]:\n                dp[i] = max(dp[i+1] + 1, dp[i])\n\n        return sum(dp)\n```\n\n- Status: may need redo\n- Analysis: two pass, so O(N) time, and need a dp to store something, so space is also O(N).\n- Time: Aug 29, 2019 10:53 AM\n\nAnother Solution(164ms)\n\n```python\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ans = 0\n        up, down = 0, 1\n        pre = 0\n\n        for cur in ratings:\n            if cur >= pre:\n                if down > 1:\n                    if down > up:\n                        ans += down - up\n                    up = down = 1\n                up = 1 if cur == pre else up + 1\n                ans += up\n            else:\n                ans += down\n                down += 1\n\n            pre = cur\n\n        if down > up:\n            ans += down - up\n\n        return ans\n```\n\n## 767. Reorganize String\n\nhttps://leetcode.com/problems/reorganize-string/\n\nGiven a string, for example, \"aab\", we need to reorganize this string so that every pair of adjacent characters are not same, for our example, we should return \"aba\". If this kind of operation is not possible, for example, \"aaab\", we just need to return an empty string.\n### Solution\n\nAn example for a much more complicated example:\n\"aafheihgiwehgsfhsaufwegb\"\n\nAfter sort by count:\n['b', 'u', 'i', 'i', 's', 's', 'w', 'w', 'a', 'a', 'a', 'e', 'e', 'e', 'f', 'f', 'f', 'g', 'g', 'g', 'h', 'h', 'h', 'h']\n\nThe 1st half will be 'b', 'u', 'i', 'i', 's', 's', 'w', 'w', 'a', 'a', 'a', 'e',\n\nThe 2nd half will be 'e', 'e', 'f', 'f', 'f', 'g', 'g', 'g', 'h', 'h', 'h', 'h'.\n\nWe merge them and the output will be `beueififsfsgwgwgagahahaheh`\n\n\n```python\n  def reorganizeString3(self, S: str) -> str:\n      a = sorted(sorted(S), key=S.count)\n      print(a)\n      h = len(a) // 2\n      a[1::2], a[::2] = a[:h], a[h:]\n      return ''.join(a) * (a[-1:] != a[-2:-1])\n```\n\nSome remaining questions:\n1. how to write a lambda in python?\n2. what does sorted(str) return? An array?\n\n\n- Status: may need redo\n- Analysis: sort will cost O(logN) in the worst situation, merge will cost O(N), so overall it's O(logN). Space, need O(N) to store the res.\n- Comment: more like a string or array problem.\n- Time: Aug 29, 2019 12:29 PM\n\n---\n\n## 714. Best Time to Buy and Sell Stock with Transaction Fee\n\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\n\nprices = [1, 3, 2, 8, 4, 9], fee = 2\n\nGiven a price array, and transaction fee, we can do buy or sell in a certain, and each time we finish a buy-sell, we need to pay the transaction fee. And you must sell the stock before you buy it again.\n\n\n### Solution\n\nThe idea here, is using 2 array to store temporary values.\n\nbuy[] and sell[], buy[i] means the max profit when the previous operation is buy. sell[i] means the max profit when the previous operation is sell.\n\n\n```\nFor our example, [1,3,2,8,4,9]\nbuy[0] = -3\nsell[0] = 0\n\nto calculate buy[1]\nyou can buy unless your previous operation is sell, so one possible value is sell[0] - prices[1] - fee = 0 - 3 - 2 = -5. Or you can don't buy that day, then it's buy[0] = -3. We keep the larger one.\n\nYou can sell unless your previous operation is buy, so one possible value is buy[0] + prices[1] = 0, or you can don't sell. it's sell[0] = 0. We still keep the larger one.\n\nKeep doing this to the end.\n```\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        buy = - prices[0] - fee\n        sell = 0\n        for i in range(1, len(prices)):\n            buy, sell = max(buy, sell - prices[i] - fee), max(sell, buy+prices[i])\n        return sell\n```\n\nThis solution is faster\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n\n        if len(prices) < 2:\n            return 0\n\n        profit = 0\n        min_price = prices[0]\n\n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            elif price > min_price + fee:\n                profit += price - min_price - fee\n                min_price = price - fee  # save the fee for higher future price\n        return profit   \n\n\"\"\"\n[1, 3, 2, 8, 4, 9]\nmin_price is 1,\nwhen price = 3 > min_price, will do nothing\nwhen price = 2, do nothing\nwhen price is 8 > min_price + fee, so we will sell it, profit += 8-1-2 = 5\nmin_price = 8-2 = 6\nso it means if we see some higher price, we will sell the stock at that price. if price < min_price, we can start another cycle, buy and sell again.\n\"\"\"\n```\n\n- Status: need redo\n- Time: Aug 29, 2019 5:11 PM\n\n----\n\n## 330. Patching Array\n\nhttps://leetcode.com/problems/patching-array/\n\nGiven an array and an integer, nums = [1,3], n = 6 for example, we need to use these nums to get possible from 1 to n. From the current array, we can only get 1,3,4. So the task is to find minimum number of patches we need to add to satisfy that requirement. For this example, we just need to add a 2. We can only use each number once, otherwise you can just use 1 to get any possible sum. `(╯' - ')╯︵ ┻━┻`.\n\n### Solution\n\nfor example nums = [2,5,10], n = 20.\n\nfor i from 1 to 20.\n\n```python\nclass Solution:\n    def minPatches2(self, nums: List[int], n: int) -> int:\n        i, far, re = 0, 0, 0\n        nums = sorted(nums)\n        while far < n :\n            if i < len(nums) and nums[i] <= far + 1:\n                far += nums[i]\n                i += 1\n            else:\n                re += 1\n                far += far+1\n        return re\n\n    def minPatches(self, nums: List[int], n: int) -> int:\n        covered = 0\n        ans = 0\n        for num in nums:\n            while num > covered + 1:\n                ans += 1\n                covered = 2 * covered + 1\n                if covered >= n:\n                    return ans\n            covered += num\n            if covered >= n:\n                return ans\n        while covered < n:\n            ans += 1\n            covered = 2 * covered + 1\n        return ans\n```\n\n- Status: need redo!\n- Time: Aug 29, 2019 8:23 PM\n\n---\n\n## 376. Wiggle Subsequence\n\nhttps://leetcode.com/problems/wiggle-subsequence/\n\nGiven an array, for example, [1,17,5,10,13,15,10,5,16,8], we need to find the length of the longest subsequence which is a wiggle subsequence. For the example above it can be [1,17,10,13,10,16,8], so we need to return 7.\n\n### Solution\n\nWe can use a dp to store the last state is up or down. If current value is larger than previous value, we can update up[i] to be down[i-1] + 1.\n\n\nfor our example,\n\n|      | 1   | 17  | 5   | 10  | 13  | 15  | 10  | 5   | 16  | 8   |\n| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| up   | `1`  | 1+1=2 |  2    | 3+1=4    |  4   | 4    |  4   |    4 |  5+1=6   | 6    |\n| down | 1   | `1`   | 2+1=3    |  3   |   3  | 3     | 4+1=5    |5     | 5    | 6+1=7    |\n\nSo we should return 7 for this example.\n\n```python\nclass Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n\n        if not nums:\n            return 0\n\n        up = [1] * len(nums)\n        down = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                up[i] = down[i-1] + 1\n                down[i] = down[i-1]\n            elif nums[i] < nums[i-1]:\n                down[i] = up[i-1] + 1\n                up[i] = up[i-1]\n            else:\n                down[i] = down[i-1]\n                up[i] = up[i-1]\n        return max(down[-1], up[-1])\n```\n\nBased on this, we can continue to optimize it by using two variable instead of two arrays.\n\n```python\nclass Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        up, down = 1, 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                up = down + 1\n            elif nums[i] < nums[i-1]:\n                down= up + 1\n        return max(down, up)\n```\n---\n\n## 452. Minimum Number of Arrows to Burst Balloons\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\n\nGiven some intervals, [[10,16], [2,8], [1,6], [7,12]], the two numbers of each tuple means the start and end of a certain ballon, for some balloons, we can burst them using one arrow.\n\n<img src=\"https://ws3.sinaimg.cn/large/006y8mN6ly1g6i5i2gy9fj31400u0x6p.jpg\" width=\"250px\"/>\n\nAs you can see, we just need 2 arrows for this example, so just return 2.\n\n```python\nclass Solution:\n    def findMinArrowShots(self, p ):\n        res = 0\n        if not p:\n            return res\n        p.sort(key=lambda x:x[1])\n        res += 1\n        start, end = p[0]\n\n        for s, e in p[1:]:\n            if s > end:\n                res += 1\n                end = e\n        return res\n```\n- Status: don't need redo\n- Time: Aug 30, 2019 11:06 AM\n\n---\n\n## 392. Is Subsequence\n\nhttps://leetcode.com/problems/is-subsequence/\n\nExample 1:\ns = \"abc\", t = \"ahbgdc\". Return true.\n\nExample 2:\ns = \"axc\", t = \"ahbgdc\". Return false.\n\n### Solution\n\n```python\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        for ch in s:\n            idx = t.find(ch)\n            if idx == -1:\n                return False\n            t = t[idx+1:]\n        return True\n```\n\n- Status: may need redo\n- Time: Aug 30, 2019 11:16 AM\n\n---\n\n\n## 765. Couples Holding Hands\n\nhttps://leetcode.com/problems/couples-holding-hands/\n\nGiven an array, row = [0, 2, 1, 3], we know 2k and 2k+1 are a couple. We want to know the minimum number of swaps so that every couple is sitting side by side.\n\nFor the example above, we just need to swap `2` and `1` => [0, 1, 2, 3]. So return 1.\n\n### Solution\n\n- Status : need redo !!!\n\n---\n\n## 402. Remove K Digits\nhttps://leetcode.com/problems/remove-k-digits/\n\nGiven a string and an integer, for example, nums = \"1432219\", k = 3. We can remove k digits from this string, and our goal is to minimize the result.\nFor that example, the smallest number we can get by removing 3 digits is 1219.\n\n### Solution\n\nSo what we can do here is, by using a stack [].\nFor our example, we start from 1 4 3 ... 9\n\nWhen the current num is smaller than the previous, and we still have k > 0, we can pop the previous num out from the stack and push this smaller num into the stack, and decrease k, because we actually deleted a character by pop that digit out from the stack.\n\nnum = 1, stack [1], k = 3\nnum = 4, stack [1, 4], k = 3\nnum = 3, stack [1, 3], k = 2,\nhere we pop the 4 out, because 14*** is always larger than 13***, so we must pop that out and replace it with 3. And because we used pop, we can only remove 2 characters later.\nnum = 2, stack [1, 2], k = 1,\nnum = 2, stack [1, 2, 2], k = 1,\nnum = 1, stack [1, 2, 1], k = 0, we can't pop that 2 out, because we used up out k.\nnum = 9, stack [1, 2, 1, 9], k = 0,\nso the result is 1219.\n\nWe also need to consider when some number are same, like when nums = '111111111', and k = 1,\nusing the idea above will not remove any digit.\n\n```python\nfrom collections import deque\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n\n        stack = deque()\n\n        for n in num:\n            while stack and stack[-1] > n and k:\n                stack.pop();\n                k -= 1\n            stack.append(n)\n\n        while k:\n            stack.pop();\n            k -= 1\n        while stack and stack[0] == '0':\n            stack.popleft()\n\n        if not stack:\n            return \"0\"\n\n        return ''.join(stack)\n```\n\n## 910. Smallest Range II\n\nhttps://leetcode.com/problems/smallest-range-ii/\n\nGiven an array and an integer,  A = [1,3,6], K = 3. We can add K or minus K for every number in A, and we want to get the smallest range form Max(A) and Min(A).\nFor the example above, it can be [1+3, 3+3, 6-3] = [4,6,3], then the range is 3.\n\n### Solution\n\n```python\ndef smallestRangeII(self, A, K):\n    A.sort()\n    res = A[-1] - A[0]\n    for i in range(len(A) - 1):\n        big = max(A[-1], A[i] + 2 * K)\n        small = min(A[i + 1], A[0] + 2 * K)\n        res = min(res, big - small)\n    return res\n```\n\n- Status : need redo! Check some other fast solutions.\n- Time: Aug 31, 2019 3:31 PM\n\n---\n\n## 659. Split Array into Consecutive Subsequences\n\nGiven an array, [1,2,3,3,4,5], if it can be split into several subsequences, and each of them is at least 3 number and are consecutive. For the example above, it can be 123 and 345. Then return true. If it can't be split, return False.\n\n### Solution\n\none idea is to maintain a priority queue, and use a HashMap to maintain the next value to that list.\n\nevery time, we will put the value into the shortest list.\n\n\n\n\n\n\n\n\n\n\n\n\n----\n"
    }
  ]
}